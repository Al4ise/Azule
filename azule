#!/bin/bash

# ENABLE CLI OPTIONS
shopt -s extglob

# SET INITIAL DIRECTORIES
rootdir="$PWD"

# SET PLATFORM
case "$(uname -s)" in
    "Linux") os="Linux" ;;
    "Darwin")
        case "$(uname -m)" in
            "arm64"|"x86_64") os="MacOS" ;;
            *) os="iOS" ;;
        esac
    ;;
esac

# PLATFORM-SPECIFIC VARIABLES
case "$os" in
    MacOS) PATH="$AZULE/bin/darwin:$PATH" ;;
    iOS) PATH="/usr/lib/Azule/bin:$PATH" ;;
    Linux) 
        PATH="$AZULE/bin/linux:$PATH"
        PATH="$AZULE/toolchain/bin:$PATH" 
    ;;
esac

# PLATFORM-SPECIFIC FUNCTIONS
case "$os" in

    iOS)
        RemovePlistKey () {
            plutil -remove -key "$1" "$2" &>/dev/null
        }

        ReplacePlistValue () {
            plutil -value "$1" -key "$2" "$3" &>/dev/null
        }

        ExtractPlistValue () {
            if [ -n "$3" ]; then
                plutil -key "$1" "$2" >> tmp 2>/dev/null
                plutil -convert xml1 tmp &>/dev/null
                sed -n "s/.*<key>\(.*\)<\/key>.*/\1/p" tmp
                rm tmp &>/dev/null
            else
                plutil -key "$1" "$2" 2>/dev/null
            fi
        }

        ExtractDEB () {
            if [ "$2" = "fetch" ]; then
                Announce "Fetching $1..." -v
                curl -sSL "$(curl -sS https://api.parcility.co/db/package/"$1" | jq -r '.data.repo.url + .data.builds[-1].Filename')" -o "tweak.deb"
                Verbose "Fetched $1" "Couldn't fetch $1" 1
                Announce "Extracting $1..."
                dpkg -x "tweak.deb" "$dir/$tweakid/Tweak"
                Verbose "Extracted $1.deb" "Couldn't extract $1.deb" 2
            else
                Announce "Extracting $(basename "$1")..."
                dpkg -x "$1" "$dir/$tweakid/Tweak"
                Verbose "Extracted $(basename "$1")" "Couldn't extract $(basename "$1")" 3
            fi
        }
    ;;

    MacOS|Linux)
        RemovePlistKey () {
            plutil -remove "$1" "$2" &>/dev/null
        }

        ReplacePlistValue () {
            plutil -replace "$2" -string "$1" "$3" &>/dev/null
        }

        ExtractPlistValue () {
            if [ -n "$3" ]; then
                psed="key"
            else
                psed="string"
            fi
            plutil -extract "$1" xml1 -o - "$2" | sed -n "s/.*<$psed>\(.*\)<\/$psed>.*/\1/p" 2>/dev/null
        }

        ExtractDEB () {
            origin_dir="$PWD"
            TMP=$(mktemp -d)
            cd "$TMP" || exit
            if [ "$2" = "fetch" ]; then
                Announce "Fetching $1..." -v
                curl -sSL "$(curl -sS https://api.parcility.co/db/package/"$1" | jq -r '.data.repo.url + .data.builds[-1].Filename')" -o "tweak.deb"
                Verbose "Fetched $1" "Couldn't fetch $1" 1 "$TMP"
                ar -x "tweak.deb"
                status="$?"
                Verbose "Extracted $(basename "$1") [ar]" "Couldn't extract $(basename "$1") [ar]" 4 -v "$TMP" -x
            else
                ar -x "$1"
                status="$?"
                Verbose "Extracted $(basename "$1") [ar]" "Couldn't extract $(basename "$1") [ar]" 4 -v "$TMP" -x
            fi
            Announce "Extracting $(basename "$1")..."
            tar -C "$dir/$tweakid/Tweak" -xf data.tar.*
            Verbose "Extracted $(basename "$1")" "Couldn't extract $(basename "$1")" 5 "$TMP"
            cd "$origin_dir" || exit
            unset origin_dir
            rm -rf "$TMP"
        }
    ;;
esac

# UNIVERSAL FUNCTIONS
Announce () {
    unset mute_verbose

    if [ -n "$silent_run" ]; then mute_verbose=1; fi
    
    for p in "$@"; do
        if [ "$p" == "-v" ] && [ -z "$verbose" ]; then mute_verbose=1; fi
    done

    if [ -z "$mute_verbose" ]; then
        echo "[*] $1"
    fi

    for p in "$@"; do
        if [[ $p =~ ^[0-9]+$ ]]; then
            exit_code="$p"
            cleanup
        fi
    done
}

Verbose () {
    tv="$?"
    unset mute_verbose

    if [ -n "$silent_run" ]; then mute_verbose=1; fi

    for p in "$@"; do
        if [ "$p" == "-v" ] && [ -z "$verbose" ]; then mute_verbose=1; fi
        if [ "$p" == "-x" ]; then tv="$status" && unset status; fi
    done
    
    if [ -z "$tv" ]; then tv=0; fi
    
    if [ "$tv" != 0 ]; then 

        echo "[*] $2"

        for p in "$@"; do
            if [ -e "$p" ]; then rm -rf "$p"; fi
        done

        for p in "$@"; do
            if [[ $p =~ ^[0-9]+$ ]]; then
                exit_code="$p"
                cleanup
            fi
        done
    elif [ -z "$mute_verbose" ]; then 
        echo "[*] $1"
    fi
}

expand() {
    if [ -z "$(echo "$1" | xargs)" ]; then
        return 0
    fi

    current_dir="$PWD"
    cd "$rootdir" || exit
    process_var="$(echo "$1" | xargs)"
    if [ -d "$1" ]; then
        (cd "$1" || exit; pwd)
    else
        if [[ "$process_var" = /* ]]; then
            process_var="$(echo "$process_var" | xargs)"
        elif [[ "$process_var" == */* ]]; then
            process_var="$(echo "$(cd "${process_var%/*}" || exit; pwd)/${process_var##*/}" | xargs)"
        else
            process_var="$(echo "$(pwd)/$process_var" | xargs)"
        fi
    fi

    if [ -e "$process_var" ]; then
        echo "$process_var"
    else
        echo "$1"
    fi
    cd "$current_dir" || exit
}

lib_basename () {
    if [[ "$1" == *.framework/* ]]; then
        echo "$(basename "$(dirname "$1")")/$(basename "$1")"
    else
        basename "$1"
    fi
}

idpath () {
    if [[ "$1" =~ ${rpath#"$dir"/"$tweakid"/} ]]; then
        echo "@rpath/$(lib_basename "$1")"
    else
        echo "@executable_path/${1#Payload/"$appname"/}"
    fi
}

cleanup () {
    rm -rf "$dir"
    cd "$rootdir" || exit
    if [ -z "$exit_code" ]; then exit_code=0; fi
    if [ -n "$ignore_errors" ]; then
        exit_code=0
    else
        exit "$exit_code"
    fi
}

help () {
    echo "Usage: azule [essential arguements] [modifiers]"
    echo
    echo "Examples:"

    if [ "$os" == "iOS" ]; then
        echo "  azule -n Foo -i com.example.foo -x appleid@example.com password123 -o ~/Foo/ -f com.alaise.example ~/Foo.bundle -a -m"
    fi

    echo "  azule -n Foo -i ~/Foo.ipa -o ~/Foo/ -f com.bar.foo"
    echo "  azule -n Foo -i ~/Foo.ipa -o ~/Foo/ -f ~/Foo.framework com.bar.foo"
    echo
    echo "Essential Arguements:"
    echo "  -i [Path/BundleID]           Specify the the IPA to patch"
    echo "  -o [Path]                    Specify an output directory"
    echo
    echo "Modifiers:"
    echo "  -f [Paths/Bundle IDs]        Specify the files or tweak Bundle IDs to import"
    echo "  -c [Version]                 Set custom version for output ipa"
    echo "  -b [BundleId]                Set custom BundleID for output ipa"
    echo "  -p [Name]                    Set custom Display Name for output ipa"
    echo "  -u                           Remove UISupportedDevices from app"
    echo "  -S                           Fakesigns iPA for use with AppSync"
    echo "  -e                           Removes App Extensions" 
    echo
    echo "Others:"
    echo "  -n [Name]                    Specify a name for the Output iPA"
    echo "  -v                           Enable Verbose Mode"
    echo "  -s                           Silence Everything But Important Errors"
    echo "  -w                           Don't Remove Watch App"
    echo "  -r                           Skip Encryption Check"
    echo "  -y                           Insert dylibs as weak"   
    echo "  -q                           Ignore errors"
    echo "  -m                           Force CydiaSubstrate.framework as a hooking library"
    echo "  -j                           Force libsubstitute.dylib as a hooking library"   
    echo "  -z                           Don't compress .app file before writing"
    echo "  -h                           Print this help menu"

    if [ "$os" == "iOS" ]; then
        echo
        echo "iOS Only:"
        echo "  -x [Apple ID] [Password]     Fetch and decrypt iPA with specified Apple ID"
        echo "  -a [Root Password]           Use APT instead of Parcility (Leave Blank for Default Password)"
        echo "  -g                           Force Update Apps"
        echo "  -l                           Don't Update Outdated Apps"
        echo "  -k                           Don't Update APT Sources (Used With -a)"
        echo "  -d                           Don't install package dependencies (Used With -a)"
    fi
    echo
    cleanup
}

# CLEAN ON EXIT
trap "cleanup" SIGINT
trap "cleanup" EXIT

# CLI ARGUEMENTS
while getopts an:i:o:c:b:x:f:p:huSewsrmjqdyzgklv args; do

    # STUFF WITH PARAMETERS
    if [[ "$args" == @(x|a|n|b|p|i|o|c|f) ]]; then
        tmp=( "$OPTARG" )
        until [[ $(eval "echo \${$OPTIND}") =~ ^-.* ]] || [ -z "$(eval "echo \${$OPTIND}")" ]; do
            tmp+=( "$(eval "echo \${$OPTIND}")" )
            OPTIND=$((OPTIND + 1))
        done
    fi

    # iOS ONLY
    if [[ "$args" == @(a|x|l|k|d|g) && "$os" != "iOS" ]]; then
        Announce "-$args is not supported on your platform" 6
    fi

    case "$args" in

        # STUFF WITH PARAMETERS
        a) root_password="$(echo "${tmp[*]}" | xargs)" && apt=1 ;;
        b) bundle="${tmp[*]}" && run=1 ;;
        c) custom_version="${tmp[*]}" && run=1 ;;
        f) IFS=" " read -r -a files <<< "${tmp[*]}" && run=1 ;;
        i) ipadir="$(expand "${tmp[*]}")" ;;
        n) name="${tmp[*]}" ;;
        o) outdir="$(expand "${tmp[*]}")" ;;
        p) displayname="${tmp[*]}" && run=1 ;;
        x) appleid="${tmp[0]}" && unset "tmp[0]" && appleid_password="${tmp[*]}" ;;

        # SWITCHES
        e) remove_extensions=1 && run=1 ;;
        j) force_hl="libsubstitute.dylib" ;;
        m) force_hl="CydiaSubstrate.framework/CydiaSubstrate" ;;
        q) ignore_errors=1 ;;
        r) ignore_encrypted=1 ;;
        s) silent_run=1 ;;
        S) fakesign=1 && run=1 ;;
        u) remove_uisd=1 && run=1 ;;
        v) verbose=1 ;;
        w) no_remove_watchapp=1 ;;
        y) weak=1 ;;
        z) no_zip=1 ;;

        # iOS ONLY SWITCHES
        d) no_recurse=1 ;;
        g) outdated=1 ;;
        k) no_apt_update=1 ;;
        l) ignore_outdated=1 ;;
        
        h) help ;;
        *) Announce "Invalid option: $*. Run 'azule -h' for help" 6 ;;
    esac
done

# VARIABLE CHECK
if [ -z "$outdir" ]; then
    Announce "No Output Directory Specified. Run 'azule -h' for help" 27
elif [ -z "$ipadir" ]; then
    Announce "No iPA Specified. Run 'azule -h' for help" 27
elif [[ -z "$run" ]]; then
    if [ "$os" != "iOS" ] || [ -e "$ipadir" ]; then
        Announce "No Modifier Specified. Run 'azule -h' for help" 27
    fi
fi

# CREATING .TMP DIRECTORIES
dir="$(mktemp -d)"
tweakid="$RANDOM"
mkdir -p "$dir/$tweakid/Tweak"
Verbose "Temporary Directory has been created" "Couldn't create Temporary Directory" 10 -v
cd "$dir/$tweakid" || exit

# INSTALLING UPDATES AND DECRYPTION
if [[ ! -e "$ipadir" && "$os" == "iOS" ]]; then
    if [ -z "$ignore_outdated" ]; then
        Announce "Checking for App Updates..."

        # CHECK IF APP IS INSTALLED
        while read -r i; do
            MCMMetadataIdentifier="$(ExtractPlistValue MCMMetadataIdentifier "$i")"
            if [ "${MCMMetadataIdentifier,,}" = "${ipadir,,}" ]; then
                info_plist="$(find "$(dirname "$i")"/*.app/ -maxdepth 1 -name Info.plist)"
                thinned="$(ExtractPlistValue variantID "$(dirname "$i")/iTunesMetadata.plist")"
                break
            fi
        done < <(find /var/containers/Bundle/Application -name .com.apple.mobile_container_manager.metadata.plist)
        
        # CHECK IF APP IS OUTDATED
        if ! curl -I google.com &>/dev/null; then Announce "No Connection to the Internet" 26; fi
        latestv="$(curl -s "http://itunes.apple.com/lookup?bundleId=$ipadir" | jq -r '.results[].version')"
        currentv="$(ExtractPlistValue CFBundleShortVersionString "$info_plist")"

        # VARIABLE CHECK
        if [ -z "$latestv" ] && [ -z "$currentv" ]; then Announce "Invalid App" 8; fi

        # UPDATING OUTDATED APPS
        if [ -n "$outdated" ] || { [ -n "$latestv" ] && [[ "$latestv" != "$currentv" || -n "$thinned" ]]; }; then
            Announce "Update Available"

            # VARIABLE CHECK
            if [ -z "$appleid" ]; then while
                printf '[*] Apple ID: '
                read -r appleid
                [ -z "$appleid" ] && Announce "No Apple ID Provided"
            do true; done; fi

            if [ -z "$appleid_password" ]; then while
                printf '[*] Password for Apple ID: '
                read -r -s appleid_password
                [ -z "$appleid_password" ] && Announce "No Password Provided"
            do true; done; fi
            printf "\n"

            # DOWNLOAD AND INSTALL UPDATES
            Announce "Downloading $ipadir..."
            ipatool-azule download -b "$ipadir" -e "$appleid" -p "$appleid_password"
            t_status="$?"
            if [ "$t_status" == "1" ]; then
                Announce "2FA Code Required"
                if [ -z "$auth_code" ]; then while
                    printf '[*] Two Factor Authentication Code: '
                    read -r -s auth_code
                    [ -z "$auth_code" ] && Announce "No 2FA Code Specified"
                do true; done; fi
                printf "\n"

                Announce "Attempting Download Again..."
                ipatool-azule download -b "$ipadir" -e "$appleid" -p "$appleid_password$auth_code"
                status="$?"
            elif [ "$t_status" != "0" ]; then 
                status=1
            fi

            Verbose "Downloaded $ipadir" "Couldn't Download $ipadir" 28 -x

            Announce "Installing $(basename "$dir/$tweakid"/*.ipa) ..."
            appinst "$dir/$tweakid"/*.ipa &>/dev/null
            Announce "Installed $(basename "$dir/$tweakid"/*.ipa)"
        else
            Announce "No Updates Available"
        fi
    fi

    # DECRYPTION: GET MAIN INFO.PLIST
    while read -r i; do
        MCMMetadataIdentifier="$(ExtractPlistValue MCMMetadataIdentifier "$i")"
        if [ "${MCMMetadataIdentifier,,}" = "${ipadir,,}" ]; then
            bfplist="$(find "$(dirname "$i")"/*.app/ -maxdepth 1 -name Info.plist)"
            break
        fi
    done < <(find /var/containers/Bundle/Application -name .com.apple.mobile_container_manager.metadata.plist)

    if [ -z "$bfplist" ]; then Announce "App Not Found" 8; fi

    # DECRYPT
    mkdir -p Payload
    appname="$(basename "$(dirname "$bfplist")")"

    while read -r i; do
        CFBundleExecutable="$(ExtractPlistValue CFBundleExecutable "$i")"
        DTPlatformName="$(ExtractPlistValue DTPlatformName "$i")"
        if [ -n "$CFBundleExecutable" ] && [ -e "$(dirname "$i")/$CFBundleExecutable" ] && otool -l "$(dirname "$i")/$CFBundleExecutable" | grep -q 'cryptid 1' && [ "$DTPlatformName" != "watchos" ]; then
            if [ -z "$dexec" ]; then

                # CHOOSING FOULDECRYPT BINARY
                ios_version="$(sw_vers | grep "ProductVersion: *" | cut -d: -f2 | xargs)"
                if [[ "${ios_version%.*}" -lt "14" ]] || [[ ! -e "/.installed_taurine" && ! -e "/.installed_unc0ver" ]]; then
                    decrypt="fouldecrypt.tfp0"
                elif [ -e "/.installed_taurine" ]; then
                    decrypt="fouldecrypt.kernrw"
                elif [ -e "/.installed_unc0ver" ]; then
                    decrypt="fouldecrypt.krw"
                fi
                
                Announce "Chose $decrypt as decryptor" -v
                Announce "Decrypting App..."
            fi

            mkdir -p "Payload/$(dirname "$i" | sed "s|^.*$appname|$appname|")"
            Announce "Decrypting $CFBundleExecutable..." -v
            "$decrypt" -v "$(dirname "$i")/$CFBundleExecutable" "Payload/$(dirname "$i" | sed "s|^.*$appname|$appname|")/$CFBundleExecutable" &>/dev/null
            status="$?"
            if [ "$status" != "0" ]; then
                qv=$(( qv + 1 ))
            fi
            Verbose "Decrypted $CFBundleExecutable" "Couldn't Decrypt $CFBundleExecutable" -v -x
            dexec=1
        fi
    done < <(find "$(dirname "$bfplist")" -name "Info.plist")

    cp -a -n "$(dirname "$bfplist")" Payload
    status="$qv"
    Verbose "Finished Decryption" "Could Not decrypt $qv files. This may cause problems later on" -x

elif [ -e "$ipadir" ]; then
    if [ "${ipadir: -4}" == ".ipa" ]; then

        # EXTRACTING IPA
        Announce "Extracting iPA..."
        unzip -q "$ipadir" -d "$dir/$tweakid"
        Verbose "IPA extracted" "Couldn't extract IPA" 11

    elif [ "${ipadir: -4}" == ".app" ]; then
        mkdir -p "$dir/$tweakid/Payload"
        cp -R "$ipadir" "$dir/$tweakid/Payload" &>/dev/null
        Verbose "Copied App to Work Directory" "Couldn't Copy App to Work Directory" 11
    fi
else
    Announce "Invalid App" 8
fi

# REMOVING PLUGINS
if [ -n "$remove_extensions" ]; then
    Announce "Removing Extensions..."
    while read -r i; do
        rm -rf "$i"
        Verbose "Removed Extensions" "Couldn't Remove Extensions"
        break
    done < <(find "$dir/$tweakid/Payload" -mindepth 2 -maxdepth 2 -type d -name PlugIns)
fi

# REMOVING WATCH APP
if [ -z "$no_remove_watchapp" ]; then
    Announce "Removing Watch App..."
    while read -r i; do
        DTPlatformName="$(ExtractPlistValue DTPlatformName "$i")"
        if [ "$DTPlatformName" == "watchos" ]; then
            if [ -z "$status" ]; then
                Announce "Removing Watch App..."
            fi
            rm -rf "$(dirname "$i")"
            status=$(( status + $? ))
        fi
    done < <(find "$dir/$tweakid/Payload" -name "Info.plist")

    if [ -n "$status" ]; then
         Verbose "Removed Watch App" "Couldn't Remove Watch App" -x
    else
        watch_app="$(find "$dir/$tweakid/Payload" -type d -name Watch.app -o -name Watch -o -name WatchApp.app)"
        if [ -n "$watch_app" ]; then
            rm -rf "$watch_app"
            Verbose "Removed Watch App" "Couldn't Remove Watch App"
        else
            Announce "There Was No Watch App To Remove"
        fi
    fi
fi

# SETTING APP VARIABLES
appname="$(basename Payload/*.app)"
executable="Payload/$appname/$(ExtractPlistValue CFBundleExecutable Payload/"$appname"/Info.plist)"
Verbose "App executable is ${executable//*.app/@executable_path}" "Couldn't set app executable" 12 -v
rpath="$(otool -l "$executable" | grep RPATH -A2 | sed 's/.*path \(.*\)/\1/' | grep -o '^\S*' | grep "^@executable_path*" | tail -1 | sed "s|@executable_path|Payload/$appname|g")"
Verbose "App rpath is ${rpath//*.app/@executable_path}" "Couldn't set app rpath" 13 -v 
mkdir -p "$rpath"

# ENCRYPTION CHECK
if [ -z "$ignore_encrypted" ]; then
    while read -r i; do
        CFBundleExecutable="$(ExtractPlistValue CFBundleExecutable "$i")"
        if [ -n "$CFBundleExecutable" ] && otool -l "$(dirname "$i")/$CFBundleExecutable" | grep -q 'cryptid 1'; then
            if [ "$(dirname "$i")/$CFBundleExecutable" == "$executable" ]; then
                Announce "Fatal Error: $(dirname "$i")/$CFBundleExecutable is encrypted" 14
            fi
        fi
    done < <(find Payload/"$appname" -name "Info.plist")
fi

# PROCESSING FILES
if [ -n "${files[*]}" ]; then
    max="${#files[@]}"
    for i in "${!files[@]}"; do
        x="$i"
        unset string
        unset "indexes[@]"
        while [[ "$x" -le "$max" ]]; do
            indexes+=( "$x" )
            string+=" ${files[x]}"
            if [ -e "$(expand "$string")" ] && [[ -z "${files[x+1]}" || ! -e "$(expand "$string ${files[x+1]}")" ]]; then

                Announce "$(basename "$string" | xargs) will be imported" -v

                case "$(expand "$string")" in
                    *.deb) 
                        ExtractDEB "$(expand "$string")"
                    ;;
                    
                    *.dylib|*.framework)
                        cp -a "$(expand "$string")" "$dir/$tweakid/Tweak"
                        Verbose "Copied $(basename "$(expand "$string")") to work directory" "Couldn't Copy $(basename "$i") to work directory" 15 -v
                    ;;

                    *)
                        merge=1
                        mkdir -p "$dir/$tweakid/Custom"
                        cp -a "$(expand "$string")" "$dir/$tweakid/Custom"
                        Verbose "Copied $(basename "$(expand "$string")") to work directory" "Couldn't Copy $(basename "$i") to work directory" 16
                    ;;
                esac
                unset string
                for g in "${indexes[@]}"; do
                    unset "files[g]"
                done
                unset "indexes[@]"
            fi
            x=$((x + 1))
        done
    done

    if [ -n "${files[*]}" ]; then

        # NETWORK CHECK
        if ! curl -I google.com &>/dev/null; then Announce "No Connection to the Internet" 26; fi
    
        # FETCHING DEBS
        if [ -n "$apt" ]; then
            
            # SET ROOT PASSWORD
            if [ -z "$root_password" ]; then
                root_password="alpine"
            fi

            if [ -z "$no_apt_update" ]; then
                Announce "Refreshing Sources..."
                echo "$root_password" | sudo -S apt-get update --allow-insecure-repositories &>/dev/null
                Verbose "Refreshed Sources" "Couldn't Refresh Sources"
            fi

            # CLEAN WORK DIRECTORY
            while read -r g; do echo "$root_password" | sudo -S rm -rf "$g"; done < <(find "/var/cache/apt/archives" -maxdepth 1 -iname '*.deb')

            if [ -n "$no_recurse" ]; then
                IFS=" " read -r -a apt_packages <<< "${files[*]}"
            else
                for j in "${files[@]}"; do

                    # NO OR
                    IFS=" " read -ra apt_no_or <<< "$(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances "$j" | grep "^\w" | xargs)"

                    # ONLY OR
                    IFS="--" read -ra apt_or <<< "$(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances "$j" | grep -A1 "^ |" | cut -d: -f2 | sed "s|>||g" | sed "s|<||g" | xargs)"
                    for i in "${apt_or[@]}"; do
                        if ! [[ "$i" =~ firmware ]] && ! [[ "$i" =~ cy+cpu.arm64 ]]; then
                            for x in $i; do
                                if [ -n "$(apt -qq list "$x" 2>/dev/null)" ]; then
                                    found=1
                                    apt_packages+=("$x")
                                    break
                                fi
                            done
                            if [ -z "$found" ]; then
                                for x in $i; do
                                    Announce "Couldn't find $x on APT"
                                done
                            fi
                            unset "found"
                        fi

                        # REMOVE UNNEEDED PACKAGES FROM NO OR
                        for y in $i; do
                            for x in "${!apt_no_or[@]}"; do
                                if [ "$y" == "${apt_no_or[x]}" ]; then
                                    unset "apt_no_or[x]"
                                    break
                                fi
                            done
                        done
                    done
                    IFS=" " read -r -a apt_packages <<< "${apt_packages[*]} ${apt_no_or[*]}"
                done
            fi

            for i in "${!apt_packages[@]}"; do
                for y in $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances com.ex.substitute org.coolstar.libhooker mobilesubstrate coreutils firmware cy+cpu.arm64 | grep "^\w"); do
                    if [ "$y" == "${apt_packages[i]}" ]; then
                        unset "apt_packages[i]"
                    fi
                done
            done

            # DOWNLOADING PACKAGES
            for x in $(echo "${apt_packages[@]}" | sort -u); do
                if [ -n "$(apt -qq list "$x" 2>/dev/null)" ]; then
                    Announce "Fetching $x..." -v
                    echo "$root_password" | sudo -S apt-get install "$x" -d -y --reinstall --allow-unauthenticated &>/dev/null
                    Verbose "Fetched $x" "Couldn't Fetch $x" 17
                else
                    Announce "Couldn't find $x on APT"
                fi
            done

            while read -r g; do
                ExtractDEB "$g"
                sudo -S rm -rf "$g"
            done < <(find "/var/cache/apt/archives" -maxdepth 1 -iname '*.deb')
        else
            for i in "${files[@]}"; do
                if [ "$(curl -sS https://api.parcility.co/db/package/"$i" | jq -r .status)" = "true" ]; then
                    ExtractDEB "$i" fetch
                else
                    Announce "$i couldn't be found" 18
                fi
            done
        fi
    fi

    # DYLIB SELECTION
    while read -r i; do
        if [[ "$i" =~ $dir/$tweakid/Custom ]]; then
            copy_path="Payload/$appname/${i#"$dir"/"$tweakid"/Custom/}"
            mkdir -p "$(dirname "$copy_path")"
        else
            copy_path="${rpath#"$dir"/"$tweakid"/Tweak/}/$(basename "$i")"
        fi

        if ! [ -e "${i%.*}.plist" ]; then
            inject+=( "$copy_path" )
            lib_dylibs+=( "$copy_path" )
            cp -a "$i" "$copy_path"
            Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16 -v
        else
            identifier="$(ExtractPlistValue Filter "${i%.*}".plist)"
            idtype="$(ExtractPlistValue Filter "${i%.*}".plist key)"
            case "$idtype" in
                Bundles)
                    ipabundleid="$(ExtractPlistValue CFBundleIdentifier Payload/"$appname"/Info.plist)"
                    if [[ "$identifier" =~ $ipabundleid ]]; then
                        inject+=( "$copy_path" )
                        cp -a "$i" "$copy_path"
                        Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16 -v
                    fi
                ;;

                Executables)
                    if [[ "$identifier" =~ $(basename "$executable") ]]; then
                        inject+=( "$copy_path" )
                        cp -a "$i" "$copy_path"
                        Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16 -v
                    fi
                ;;
            esac
        fi
    done < <(find "$dir/$tweakid/Tweak" "$dir/$tweakid/Custom" ! -type l -iname '*.dylib' 2>/dev/null)

    # MOVING FRAMEWORKS TO APP DIRECTORY
    while read -r i; do
        if [[ "$i" =~ $dir/$tweakid/Custom ]]; then
            copy_path="Payload/$appname/${i#"$dir"/"$tweakid"/Custom/}"
            mkdir -p "$(dirname "$copy_path")"
        else
            copy_path="${rpath#"$dir"/"$tweakid"/Tweak/}/$(basename "$i")"
        fi

        if [ ! -e "$copy_path" ]; then
            if [ -e "$i/Info.plist" ]; then
                cp -a "$i" "$copy_path"
                Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16 -v
                inject+=( "$copy_path/$(ExtractPlistValue CFBundleExecutable "$i/Info.plist")" )
                lib_dylibs+=( "$copy_path/$(ExtractPlistValue CFBundleExecutable "$i/Info.plist")" )
            fi
        fi
    done < <(find "$dir/$tweakid/Tweak" "$dir/$tweakid/Custom" ! -type l -iname '*.framework' ! -path '*PreferenceBundles/*' ! -path '*.bundle/*' ! -path '*.framework/*' 2>/dev/null)

    # MOVING BUNDLES
    while read -r i; do
        rm -rf "Payload/$appname/$(basename "$i")"
        cp -a "$i" "Payload/$appname/"
        Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16 -v
    done < <(find "$dir/$tweakid/Tweak" ! -type l -iname '*.bundle' ! -path '*PreferenceBundles/*' ! -path '*.bundle/*' ! -path '*.framework/*')

    # FIXING LINKS
    for i in "${inject[@]}"; do

        ldid -r -M "$i" &>/dev/null
        Verbose "Codesign stripped from $(lib_basename "$i")" "Couldn't strip codesign from $(lib_basename "$i")" 19 -v

        for l in $(otool -L "$i" | cut -d ' ' -f1); do
            for x in "${inject[@]}"; do
                if [[ "$l" =~ $(lib_basename "$x") ]]; then
                    if [[ "$l" =~ $(lib_basename "$i") ]]; then
                        install_name_tool -id "$(idpath "$i")" "$i" &>/dev/null
                        tid=$(( tid + $? ))
                        break
                    else
                        install_name_tool -change "$l" "$(idpath "$x")" "$i" &>/dev/null
                        tlnk=$(( tlnk + $? ))
                        if ! [[ "${linked[*]}" =~ $x ]]; then linked+=( "$x" ); fi
                        break
                    fi
                fi
            done
        done
    done

    # VERBOSE
    status="$tid"
    if [ -n "$tid" ]; then
        Verbose "ID Successful" "$tid file(s) failed to ID" 20 -x
    fi

    status="$tlnk"
    if [ -n "$tlnk" ]; then
        Verbose "Re-Link Successful" "$tlnk Re-Links failed" 21 -x
    fi

    # INJECT HOOKING LIBRARY
    if [ -n "${inject[*]}" ]; then
        for hookinglibrary in "libsubstitute.dylib" "CydiaSubstrate.framework/CydiaSubstrate"; do
            unset "hl"
            for i in "${inject[@]}"; do
                for l in $(otool -L "$i" | cut -d ' ' -f1); do
                    if [[ "$l" =~ $hookinglibrary ]]; then
                        if [ ! -e "$rpath/$hookinglibrary" ]; then
                            if [ -n "$force_hl" ]; then
                                hl="$force_hl"
                            else
                                hl="$hookinglibrary"
                            fi

                            if [[ "$hl" =~ .framework ]]; then
                                hl_file="$(dirname "$hl")"
                            else
                                hl_file="$hl"
                            fi

                            if [ "$os" == "iOS" ]; then
                                cp -a "/usr/lib/Azule/lib/$hl_file" "$rpath"
                            elif ! cp -a "$AZULE/lib/$hl_file" "$rpath" &>/dev/null; then
                                Announce "$hl_file not downloaded, please run setup-azule." 22
                            fi
                        fi

                        install_name_tool -change "$l" @rpath/"$hl" "$i" &>/dev/null
                        status=$(( status + $? ))
                        break
                    fi
                done
            done
            if [ -n "$hl" ]; then
                Verbose "Linked $hl" "Failed injecting $hl in $status file(s)" 23 -x
            fi
        done
    fi

    # INJECTING LIBRARIES
    for i in $(printf "%s\n" "${inject[@]}" | sort -u); do
        id_path="$(idpath "$i")"
        if ! { [[ "${linked[*]}" =~ $i && "${lib_dylibs[*]}" =~ $i ]] || [[ "$(otool -L "$executable" | cut -d ' ' -f1 | xargs)" =~ $id_path ]]; }; then
            if [ -n "$weak" ]; then 
                insert_dylib --inplace --weak --no-strip-codesig "$id_path" "$executable" &>/dev/null
                Verbose "Injected $(lib_basename "$i") as weak" "Couldn't inject $(lib_basename "$i")" 24
            else
                insert_dylib --inplace --no-strip-codesig "$id_path" "$executable" &>/dev/null
                Verbose "Injected $(lib_basename "$i")" "Couldn't inject $(lib_basename "$i")" 24
            fi
        fi
    done

    # MERGING FOLDERS
    if [ -n "$merge" ]; then
        cp -R "$dir/$tweakid"/Custom/* "Payload/$appname"
    fi
fi

# REMOVING UISUPPORTEDDEVICES
if [ -n "$remove_uisd" ]; then
    UISupportedDevices="$(ExtractPlistValue UISupportedDevices Payload/"$appname"/Info.plist)"
    if [ -n "$UISupportedDevices" ]; then
        RemovePlistKey UISupportedDevices Payload/"$appname"/Info.plist
        Verbose "Removed UISupportedDevices from app" "Couldn't remove UISupportedDevices from app"
    fi
fi

# CHANGING BUNDLEID
if [ -n "$bundle" ]; then
    orig_bundleid="$(ExtractPlistValue CFBundleIdentifier Payload/"$appname"/Info.plist)"
    Verbose "Obtained Original BundleID" "Couldn't Obtain Original BundleID"

    while read -r i; do
        CFBundleIdentifier="$(ExtractPlistValue CFBundleIdentifier "$i")"
        if [[ "$CFBundleIdentifier" =~ $orig_bundleid ]]; then
            CFBundleIdentifier="${CFBundleIdentifier//"$orig_bundleid"/"$bundle"}"
            ReplacePlistValue "$CFBundleIdentifier" CFBundleIdentifier "$i"
            status=$(( status + $? ))
        fi
    done < <(find Payload/"$appname" -name "Info.plist")
    Verbose "Changed App BundleID to $bundle" "Couldn't Change App BundleID" -x
fi

# CHANGING DISPLAY NAME
if [ -n "$displayname" ]; then
    ReplacePlistValue "$displayname" CFBundleDisplayName Payload/"$appname"/Info.plist
    Verbose "Changed App Display Name to $displayname" "Couldn't Change App Display Name"
fi

# CHANGING VERSION
if [ -n "$custom_version" ]; then
    ReplacePlistValue "$custom_version" CFBundleVersion Payload/"$appname"/Info.plist
    ReplacePlistValue "$custom_version" CFBundleShortVersionString Payload/"$appname"/Info.plist
    Verbose "Changed App Version to $custom_version" "Couldn't Change App Version"
fi

# FAKESIGNING
if [ -n "$fakesign" ]; then
    Announce "Fakesigning iPA..."
        while read -r i; do
            ldid -s "$i" &>/dev/null
            Verbose "Fakesigned $(lib_basename "$i")" "Couldn't Fakesign $(lib_basename "$i")" -v
        done < <(find Payload -type f ! -name "*.*" ! -name "CodeResources" ! -name PkgInfo)
    Verbose "Finished Fakesigning" "Couldn't Fakesign App"
fi

# GENERATING IPA
if [ -n "$run" ] || [ -n "$bfplist" ]; then

    # SETTING OUTPUT DIRECTORY AND NAME
    if ! [ "${outdir: -4}" == ".ipa" ]; then
        if [ -n "$no_zip" ]; then
            if [ -z "$name" ]; then
                outdir="$outdir/$appname"
            else
                if [ "$name" == "*.app" ]; then
                    outdir="$outdir/$name"
                else
                    outdir="$outdir/$name.app"
                fi
            fi
        else
            if [ -z "$name" ]; then
                name="$(basename "$ipadir" .ipa)"
                for i in "${files[@]}"; do
                    name+="+$(basename "$i")"
                done
            fi
            outdir="$outdir/$name.ipa"
        fi
    fi

    # SHORTEN OUTPUT NAME IF NEEDED
    if [[ ${#outdir} -gt 264 ]]; then
        outdir="${outdir::${#outdir}-4}"
        characters_to_remove=$(( ${#outdir} - 264 ))
        outdir="${outdir::${#outdir}-$characters_to_remove}.ipa"
        Announce "Shortened File Name"
    fi

    # CREATING OUTPUT DIRECTORY
    mkdir -p "$(dirname "$outdir")"

    if [ -e "$outdir" ]; then rm -rf "$outdir"; fi
    if [ -n "$no_zip" ]; then
        Announce "Generating App..."
        mv Payload/"$appname" "$outdir" 
        status="$?"
    else
        Announce "Generating iPA..."
        zip -rq "$outdir" Payload
        status="$?"
    fi
    Verbose "Generated IPA at $outdir" "Couldn't generate IPA" 25
fi
