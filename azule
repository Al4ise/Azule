#!/bin/bash

# ENABLE CLI OPTIONS
shopt -s extglob

# SET INITIAL DIRECTORIES
rootdir="$PWD"

# SET PLATFORM
case "$(uname -s)" in
    "Linux") os="Linux" ;;
    "Darwin")
        case "$(uname -m)" in
            "arm64"|"x86_64") os="MacOS" ;;
            *) os="iOS" ;;
        esac
    ;;
esac

# PLATFORM-SPECIFIC VARIABLES
case "$os" in
    MacOS)
        # Add tweak tools to PATH
        if [ -d "$AZULE/bin/darwin" ] ; then
            PATH="$AZULE/bin/darwin:$PATH"
        fi
    ;;

    Linux)
        # Add tweak tools to PATH
        if [ -d "$AZULE/bin/linux" ] ; then
            PATH="$AZULE/bin/linux:$PATH"
        fi
        # Add toolchain to PATH
        if [ -d "$AZULE/toolchain/bin" ] ; then
            PATH="$AZULE/toolchain/bin:$PATH"
        fi
    ;;
esac

# PLATFORM-SPECIFIC FUNCTIONS
case "$os" in

    iOS)
        RemovePlistKey () {
            plutil -remove -key "$1" "$2" &>/dev/null
        }

        ReplacePlistValue () {
            plutil -value "$1" -key "$2" "$3" &>/dev/null
        }

        ExtractPlistValue () {
            if [ -n "$3" ]; then
                plutil -key "$1" "$2" >> tmp 2>/dev/null
                plutil -convert xml1 tmp &>/dev/null
                sed -n "s/.*<key>\(.*\)<\/key>.*/\1/p" tmp
                rm tmp &>/dev/null
            else
                plutil -key "$1" "$2" 2>/dev/null
            fi
        }

        ExtractDEB () {
            if [ "$2" = "fetch" ]; then
                Announce "Fetching $1..."
                curl -sSL "$(curl -sS https://api.parcility.co/db/package/"$1" | jq -r '.data.repo.url + .data.builds[-1].Filename')" -o "tweak.deb"
                Verbose "Fetched $1" "Couldn't fetch $1" 1
                Announce "Extracting $1..."
                dpkg -x "tweak.deb" "$dir/$tweakid/Tweak"
                Verbose "Extracted $1.deb" "Couldn't extract $1.deb" 2
            else
                Announce "Extracting $(basename "$1")..."
                dpkg -x "$1" "$dir/$tweakid/Tweak"
                Verbose "Extracted $(basename "$1")" "Couldn't extract $(basename "$1")" 3
            fi
        }
    ;;

    MacOS|Linux)
        RemovePlistKey () {
            plutil -remove "$1" "$2" &>/dev/null
        }

        ReplacePlistValue () {
            plutil -replace "$2" -string "$1" "$3" &>/dev/null
        }

        ExtractPlistValue () {
            if [ -n "$3" ]; then
                psed="key"
            else
                psed="string"
            fi
            plutil -extract "$1" xml1 -o - "$2" | sed -n "s/.*<$psed>\(.*\)<\/$psed>.*/\1/p" 2>/dev/null
        }

        ExtractDEB () {
            origin_dir="$PWD"
            TMP=$(mktemp -d)
            cd "$TMP" || exit
            if [ "$2" = "fetch" ]; then
                Announce "Fetching $1..."
                curl -sSL "$(curl -sS https://api.parcility.co/db/package/"$1" | jq -r '.data.repo.url + .data.builds[-1].Filename')" -o "tweak.deb"
                Verbose "Fetched $1" "Couldn't fetch $1" 1 "$TMP"
                ar -x "tweak.deb"
                status="$?"
                Verbose "Extracted $(basename "$1") [ar]" "Couldn't extract $(basename "$1") [ar]" 4 -v "$TMP" -x
            else
                ar -x "$1"
                status="$?"
                Verbose "Extracted $(basename "$1") [ar]" "Couldn't extract $(basename "$1") [ar]" 4 -v "$TMP" -x
            fi
            Announce "Extracting $(basename "$1")..."
            tar -C "$dir/$tweakid/Tweak" -xf data.tar.*
            Verbose "Extracted $(basename "$1")" "Couldn't extract $(basename "$1")" 5 "$TMP"
            cd "$origin_dir" || exit
            unset origin_dir
            rm -rf "$TMP"
        }
    ;;
esac

# UNIVERSAL FUNCTIONS
Announce () {
    unset mute_verbose

    if [ -n "$silent_run" ]; then mute_verbose=1; fi
    
    for p in "$@"; do
        if [ "$p" == "-v" ] && [ -z "$verbose" ]; then mute_verbose=1; fi
    done

    if [ -z "$mute_verbose" ]; then
        echo "[*] $1"
    fi

    for p in "$@"; do
        if [[ $p =~ ^[0-9]+$ ]]; then
            exit_code="$p"
            cleanup
        fi
    done
}

Verbose () {
    tv="$?"
    unset mute_verbose

    if [ -n "$silent_run" ]; then mute_verbose=1; fi

    for p in "$@"; do
        if [ "$p" == "-v" ] && [ -z "$verbose" ]; then mute_verbose=1; fi
        if [ "$p" == "-x" ]; then tv="$status" && unset status; fi
    done
    
    if [ -z "$tv" ]; then tv=0; fi
    
    if [ "$tv" != 0 ]; then 

        echo "[*] $2"

        for p in "$@"; do
            if [ -e "$p" ]; then rm -rf "$p"; fi
        done

        for p in "$@"; do
            if [[ $p =~ ^[0-9]+$ ]]; then
                exit_code="$p"
                cleanup
            fi
        done
    elif [ -z "$mute_verbose" ]; then 
        echo "[*] $1"
    fi
}

network_check () {
    if ! curl -I google.com &>/dev/null; then
        Announce "No Connection to the Internet" 26
    fi
}

cleanup () {
    rm -rf "$dir"
    cd "$rootdir" || exit
    if [ -z "$exit_code" ]; then
        exit_code=0
    fi
    if [ -n "$ignore_errors" ]; then
        exit_code=0
    else
        exit "$exit_code"
    fi
}

help () {
    echo
    echo "Usage: azule [arguements]"
    echo
    echo "Mandatory Arguements:"
    echo "  -i [Path/BundleID]           Specify the path to the IPA to patch"
    echo "  -o [Path]                    Specify an output directory"
    echo
    echo "Optional Arguements:"
    echo "  -n [Name]                    Specify an Output Name"
    echo "  -f [Paths/Bundle IDs]        Specify the files or tweak Bundle IDs to import"
    echo "  -c [Version]                 Set custom version for output ipa"
    echo "  -b [BundleId]                Set custom BundleID for output ipa"
    echo "  -p [Name]                    Set custom Display Name for output ipa"
    echo "  -u                           Remove UISupportedDevices from app"
    echo "  -v                           Enable Verbose Mode"
    echo "  -s                           Silence Everything But Important Errors"
    echo "  -S                           Fakesigns iPA for use with AppSync"
    echo "  -e                           Removes App Extensions"
    echo "  -w                           Removes Watch App"
    echo "  -r                           Skip Encryption Check"
    echo "  -q                           Ignore errors"
            
    if [ "$os" == "iOS" ]; then
        echo "  -x [Apple ID] [Password]     Fetch and decrypt iPA"
        echo "  -a [Root Password]           Use APT instead of Parcility (Leave Blank for Default Password)"
        echo "  -m                           Enforce Updating Apps Before Decrypting"
        echo "  -l                           Don't Update Outdated Apps"
        echo "  -z                           Don't Update APT Sources (Used With -a)"
        echo "  -j                           Don't install package dependencies (Used With -a)"
    fi
            
    echo
    echo "Examples:"
    echo "  azule -n Foo -i com.example.foo -o ~/Foo/ -f ~/Foo.dylib ~/Foo.bundle"
    echo "  azule -n Foo -i ~/Foo.ipa -o ~/Foo/ -f com.bar.foo -d Foo.dylib"
    echo "  azule -n Foo -i ~/Foo.ipa -o ~/Foo/ -f ~/Foo.framework com.bar.foo -d Foo.dylib"
    echo
    echo "  -h                           Print this help menu"
    echo
    exit
}

# CLEAN ON EXIT
trap "cleanup" SIGINT
trap "cleanup" EXIT

# CLI ARGUEMENTS
while getopts an:i:o:c:b:x:f:d:p:huSewsrqjmzlv args; do

    # STUFF WITH PARAMETERS
    if [[ "$args" == @(x|a|n|b|p|i|o|c|f) ]]; then
        tmp=( "$OPTARG" )
        until [[ $(eval "echo \${$OPTIND}") =~ ^-.* ]] || [ -z "$(eval "echo \${$OPTIND}")" ]; do
            tmp+=( "$(eval "echo \${$OPTIND}")" )
            OPTIND=$((OPTIND + 1))
        done
    fi

    # iOS ONLY
    if [[ "$args" == @(a|x|l|m|z|j) ]]; then
        if [ "$os" != "iOS" ]; then
            Announce "-$args is not supported on your platform" 6
        fi
    fi

    case "$args" in

        # STUFF WITH PARAMETERS
        n) name="${tmp[*]}" ;;
        b) bundle="${tmp[*]}" && run=1 ;;
        p) displayname="${tmp[*]}" && run=1 ;;
        i) ipadir="$(eval echo "${tmp[*]}")" ;;
        o) outdir="${tmp[*]}" ;;
        c) custom_version="${tmp[*]}" && run=1 ;;
        f) files+=( ${tmp[@]} ) && run=1 ;;
        a) root_password="$(echo "${tmp[*]}" | xargs)" && apt=1 ;;
        x) appleid="${tmp[0]}" && unset "tmp[0]" && appleid_password="${tmp[*]}" ;;

        # SWITCHES
        u) remove_uisd=1 && run=1 ;;
        v) verbose="-v" ;;
        e) remove_extensions=1 && run=1 ;;
        w) remove_watchapp=1 && run=1 ;;
        S) fakesign=1 && run=1 ;;
        r) ignore_encrypted=1 ;;
        s) silent_run=1 ;;
        q) ignore_errors=1 ;;

        # iOS ONLY SWITCHES
        j) no_recurse=1 ;;
        l) ignore_outdated=1 ;;
        m) outdated=1 ;;
        z) no_apt_update=1 ;;
        
        h) help ;;
        *) Announce "Invalid option: $*. Run "azule -h" for help" 6 ;;
    esac
done

# READING OUTPUT DIRECTORY
if [ -z "$outdir" ]; then while
    printf '[*] Output Directory: '
    read -r outdir
    [ -z "$outdir" ] && Announce "No Output Directory Specified"
do true; done; fi

# READING IPA
if [ -z "$ipadir" ]; then while
    printf '[*] Path to IPA: '
    read -r tmp
    ipadir="$(eval echo "$tmp")"
    [ -z "$ipadir" ] && Announce "No iPA Specified"
do true; done; fi

# CREATING .TMP DIRECTORIES
dir="$(mktemp -d)"

tweakid="$RANDOM"
mkdir -p "$dir/$tweakid/Tweak"
Verbose "Temporary Directory $dir/$tweakid/Tweak has been created" "Couldn't create Temporary Directory" 10 -v

cd "$dir/$tweakid" || exit

if [ ! -e "$ipadir" ]; then
    if [ "$os" != "iOS" ]; then
        Announce "Invalid iPA" 7
    else
        Announce "Checking for App Updates..."

        # CHECK IF APP IS INSTALLED
        while read -r i; do
            if [ "$(ExtractPlistValue MCMMetadataIdentifier "$i")" = "$ipadir" ]; then
                bfplist="$(find "$(dirname "$i")"/*.app/ -maxdepth 1 -name Info.plist)"
                thinned="$(ExtractPlistValue variantID "$(dirname "$i")/iTunesMetadata.plist")"
                break
            fi
        done < <(find /var/containers/Bundle/Application -name .com.apple.mobile_container_manager.metadata.plist)

        # CHECK IF APP IS OUTDATED
        network_check
        latestv="$(curl -s "http://itunes.apple.com/lookup?bundleId=$ipadir" | jq -r '.results[].version')"
        currentv="$(ExtractPlistValue CFBundleShortVersionString "$bfplist")"

        if [ -z "$latestv" ] && [ -z "$currentv" ]; then
            Announce "Invalid App" 8
        fi

        if [ -n "$latestv" ] && [[ "$latestv" != "$currentv" || -n "$thinned" ]]; then
            if [ -z "$ignore_outdated" ]; then
                Announce "Update Available"
                outdated=1
            fi
        fi

        if [ -n "$outdated" ]; then

            # VARIABLE CHECK
            if [ -z "$appleid" ]; then while
                printf '[*] Apple ID: '
                read -r appleid
                [ -z "$appleid" ] && Announce "No Apple ID Provided"
            do true; done; fi

            if [ -z "$appleid_password" ]; then while
                printf '[*] Password for Apple ID: '
                read -r -s appleid_password
                [ -z "$appleid_password" ] && Announce "No Password Provided"
            do true; done; fi

            ipatool-azule download -b "$ipadir" -e "$appleid" -p "$appleid_password"
            Verbose "Downloaded $ipadir" "Couldn't Download $ipadir" 28

            Announce "Installing $(basename "$dir/$tweakid"/*.ipa) ..."
            appinst "$dir/$tweakid"/*.ipa &>/dev/null
            Announce "Installed $(basename "$dir/$tweakid"/*.ipa)"
        else
            Announce "No Updates Available"
        fi
    fi
fi

# VARIABLE CHECK
if [ -z "$run" ] && [ -e "$ipadir" ]; then
    Announce "Insufficient Arguements"
    Announce "Run "azule -h" for usage instructions" 27
fi

# SETTING OUTPUT DIRECTORY AND NAME

outdir="$(eval echo "$outdir" | sed "s|\.|$rootdir|")"
if [ "${outdir: -4}" == ".ipa" ]; then
    output="$outdir"
else
    if [ -z "$name" ]; then
        name="$(basename "$ipadir" .ipa)"
        for i in "${files[@]}"; do
            name+="+$(basename "$i")"
        done
    fi
    output="$outdir/$name.ipa"
fi

# SHORTEN OUTPUT NAME IF NEEDED
if [[ ${#output} -gt 264 ]]; then
    output="${output::${#output}-4}"
    characters_to_remove=$(( ${#output} - 264 ))
    output="${output::${#output}-$characters_to_remove}.ipa"
    Announce "Shortened File Name"
fi

# CREATING OUTPUT DIRECTORY
mkdir -p "$(dirname "$output")"
test -w "$(dirname "$output")"
Verbose "iPA will be written to $output" "$output is an invalid output path" 9 -v

# DECRYPTION
if [ ! -e "$ipadir" ]; then

    # GET MAIN INFO.PLIST
    while read -r i; do
        if [ "$(ExtractPlistValue MCMMetadataIdentifier "$i")" = "$ipadir" ]; then
            bfplist="$(find "$(dirname "$i")"/*.app/ -maxdepth 1 -name Info.plist)"
            break
        fi
    done < <(find /var/containers/Bundle/Application -name .com.apple.mobile_container_manager.metadata.plist)

    # DECRYPT
    if [ -n "$bfplist" ]; then
        mkdir -p Payload
        appname="$(basename "$(dirname "$bfplist")")"

        while read -r i; do
            CFBundleExecutable="$(ExtractPlistValue CFBundleExecutable "$i")"
            DTPlatformName="$(ExtractPlistValue DTPlatformName "$i")"
            if [ -n "$CFBundleExecutable" ] && [ -e "$(dirname "$i")/$CFBundleExecutable" ] && otool -l "$(dirname "$i")/$CFBundleExecutable" | grep -q 'cryptid 1' && [ "$DTPlatformName" != "watchos" ]; then
                if [ -z "$status" ]; then
                    Announce "Decrypting App..."
                fi
                mkdir -p "Payload/$(dirname "$i" | sed "s|^.*$appname|$appname|")"
                flexdecrypt "$(dirname "$i")/$CFBundleExecutable" --output "Payload/$(dirname "$i" | sed "s|^.*$appname|$appname|")/$CFBundleExecutable" &>/dev/null
                Verbose "Decrypted $CFBundleExecutable" "Couldn't Decrypt $CFBundleExecutable" -v
                status=0
            fi
        done < <(find "$(dirname "$bfplist")" -name "Info.plist")
    
        rsync --ignore-existing -a "$(dirname "$bfplist")" Payload
        Verbose "Finished Decryption" "App Was Not Encrypted" -x 
        unzipped=1
    fi
fi

# EXTRACTING IPA
if [[ -n "$run" && -z "$unzipped" ]]; then
    Announce "Extracting iPA..."
    unzip -q "$ipadir" -d "$dir/$tweakid"
    Verbose "IPA extracted" "Couldn't extract IPA" 11
fi

# REMOVING PLUGINS
if [ -n "$remove_extensions" ]; then
    Announce "Removing Extensions..."
    while read -r i; do
        rm -rf "$i"
        Verbose "Removed Extensions" "Couldn't Remove Extensions"
        break
    done < <(find "$dir/$tweakid/Payload" -mindepth 2 -maxdepth 2 -type d -name PlugIns)
fi

# REMOVING WATCH APP
if [ -n "$remove_watchapp" ] || [ -n "$unzipped" ]; then
    while read -r i; do
        DTPlatformName="$(ExtractPlistValue DTPlatformName "$i")"
        if [ "$DTPlatformName" == "watchos" ]; then
            if [ -z "$status" ]; then
                Announce "Removing Watch App..."
            fi
            rm -rf "$(dirname "$i")"
            status=$(( status + $? ))
        fi
    done < <(find "$dir/$tweakid/Payload" -name "Info.plist")


    if [ -n "$status" ]; then
         Verbose "Removed Watch App" "Couldn't Remove Watch App" -x
    else
        watch_app="$(find "$dir/$tweakid/Payload" -type d -name Watch.app)"
        if [ -n "$watch_app" ]; then
            rm -rf "$watch_app"
            Verbose "Removed Watch App" "Couldn't Remove Watch App"
        else
            Announce "There Was No Watch App To Remove"
        fi
    fi
fi

# SETTING APP VARIABLES
appname="$(basename Payload/*.app)"
executable="Payload/$appname/$(ExtractPlistValue CFBundleExecutable Payload/"$appname"/Info.plist)"
Verbose "App executable is $(echo "$executable" | sed "s|^.*.app/|@executable_path/|")" "Couldn't set app executable" 12 -v
rpath="$(otool -l "$executable" | grep RPATH -A2 | sed 's/.*path \(.*\)/\1/' | grep -o '^\S*' | grep "^@executable_path*" | tail -1 | sed "s|@executable_path|Payload/$appname|g" 
)"
Verbose "App rpath is $(echo "$rpath" | sed "s|^.*.app/|@executable_path/|")" "Couldn't set app rpath" 13 -v

mkdir -p "$rpath"

# ENCRYPTION CHECK
if [ -z "$ignore_encrypted" ]; then
    while read -r i; do
        CFBundleExecutable="$(ExtractPlistValue CFBundleExecutable "$i")"
        if [ -n "$CFBundleExecutable" ] && otool -l "$(dirname "$i")/$CFBundleExecutable" | grep -q 'cryptid 1'; then
            if [[ "$(dirname "$i")/$CFBundleExecutable" =~ .app/Frameworks || "$(dirname "$i")/$CFBundleExecutable" == "$executable" ]]; then
                Announce "Fatal Error: $(dirname "$i")/$CFBundleExecutable is encrypted" 14
            fi
        fi
    done < <(find Payload/"$appname" -name "Info.plist")
fi

# PROCESSING FILES
if [ -n "$files" ]; then
    max="${#files[@]}"
    for i in "${!files[@]}"; do
        x="$i"
        unset string
        unset "indexes[@]"
        while [[ "$x" -le "$max" ]]; do
            indexes+=( "$x" )
            string+=" ${files[x]}"
            if [ -e "$(eval echo "$string")" ] && [[ -z "${files[x+1]}" || ! -e "$(eval echo "$string ${files[x+1]}")" ]]; then

                Announce "$(basename "$string") will be imported" -v

                case "$(eval echo "$string")" in
                    *.deb) 
                        ExtractDEB "$(eval echo "$string")"
                    ;;
                    
                    *.dylib)
                        rsync -a "$(eval echo "$string")" "$dir/$tweakid/Tweak"
                        Verbose "Copied $(basename "$(eval echo "$string")") to work directory" "Couldn't Copy $(basename "$i") to work directory" 15 -v
                    ;;

                    *.framework)
                        rsync -a "$(eval echo "$string")" "$dir/$tweakid/Tweak"
                        Verbose "Copied $(basename "$(eval echo "$string")") to work directory" "Couldn't Copy $(basename "$i") to work directory" 15 -v
                    ;;

                    *)
                        rsync -a "$(eval echo "$string")" Payload/"$appname"
                        Verbose "Copied $(basename "$(eval echo "$string")") to app directory" "Couldn't Copy $(basename "$i") to app directory" 16
                    ;;
                esac
                unset string
                for g in "${indexes[@]}"; do
                    unset "files[g]"
                done
                unset "indexes[@]"
            fi
            x=$((x + 1))
        done
    done
    
    # FETCHING DEBS
    network_check
    if [ "$os" == "iOS" ] && [ -n "$apt" ]; then
            
        # SET ROOT PASSWORD
        if [ -z "$root_password" ]; then
            root_password="alpine"
        fi

        if [ -z "$no_apt_update" ]; then
            Announce "Refreshing Sources..."
            echo "$root_password" | sudo -S apt-get update --allow-insecure-repositories &>/dev/null
            Verbose "Refreshed Sources" "Couldn't Refresh Sources"
        fi

        while read -r g; do echo "$root_password" | sudo -S rm -rf "$g"; done < <(find "/var/cache/apt/archives" -maxdepth 1 -iname '*.deb')

        if [ -n "$no_recurse" ]; then
            apt_packages=( "${files[@]}" )
        else
            for j in "${files[@]}"; do
                tmp=( $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances "$j" | grep "^\w") )
                apt_or=( $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances "$j" | grep -A1 "^ |" | grep ": " | cut -d: -f2 | xargs) )

                for o in "${!apt_or[@]}"; do
                    if [ -n "$(apt -qq list "${apt_or[o]}" 2>/dev/null)" ]; then
                        unset "apt_or[o]"
                        break
                    fi
                done
                rm_packages+=("${apt_or[@]}")
                for t in "${tmp[@]}"; do
                    if [[ "$t" == @(com.ex.substitute|org.coolstar.libhooker|mobilesubstrate|firmware) ]]; then
                        rm_packages+=( $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances "$t" | grep "^\w") )
                    fi
                done
                apt_packages+=( ${tmp[@]} )
            done

            for q in "${!apt_packages[@]}"; do
                for z in "${!rm_packages[@]}"; do
                    if [ "${apt_packages[q]}" == "${rm_packages[z]}" ]; then
                        unset "apt_packages[q]"
                        unset "rm_packages[z]"
                        break
                    fi
                done
            done
        fi

        # DOWNLOADING PACKAGES
        for x in "${apt_packages[@]}"; do
            Announce "Fetching $x"
            echo "$root_password" | sudo -S apt-get install "$x" -d -y --reinstall --allow-unauthenticated &>/dev/null
            Verbose "Fetched $x" "Couldn't Fetch $x" 17
        done

        while read -r g; do
            ExtractDEB "$g"
            sudo -S rm -rf "$g"
        done < <(find "/var/cache/apt/archives" -maxdepth 1 -iname '*.deb')
        
    else
        for i in "${files[@]}"; do
            if [ "$(curl -sS https://api.parcility.co/db/package/"$i" | jq -r .status)" = "true" ]; then
                ExtractDEB "$i" fetch
            else
                Announce "$i couldn't be found" 18
            fi
        done
    fi

    # SPECIFYING DYLIBS
    while read -r i; do dylibs+=("$i"); done < <(find "$dir/$tweakid/Tweak" ! -type l -iname '*.dylib')

    # DYLIB SELECTION
    for i in "${dylibs[@]}"; do
        if ! [ -e "${i%.*}.plist" ]; then
            inject+=( "$(basename "$i")" )
            lib_dylibs+=( "$(basename "$i")" )
            rsync -a "$i" "$rpath"
            Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16 -v
        else
            identifier="$(ExtractPlistValue Filter "${i%.*}".plist)"
            idtype="$(ExtractPlistValue Filter "${i%.*}".plist key)"

            case "$idtype" in
                Bundles)
                    ipabundleid="$(ExtractPlistValue CFBundleIdentifier Payload/"$appname"/Info.plist)"
                    
                    if [[ "$identifier" =~ $ipabundleid ]]; then
                        inject+=( "$(basename "$i")" )
                        rsync -a "$i" "$rpath"
                        Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16 -v
                    fi
                ;;

                Executables)
                    if [[ "$identifier" =~ $(basename "$executable") ]]; then
                        inject+=( "$(basename "$i")" )
                        rsync -a "$i" "$rpath"
                        Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16 -v
                    fi
                ;;
                
            esac
        fi
    done

    # MOVING FRAMEWORKS TO APP DIRECTORY
    while read -r i; do
        if [ -e "$i/Info.plist" ]; then
            rsync -a "$i" "$rpath"
            Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16
            inject+=( "$(basename "$i")/$(ExtractPlistValue CFBundleExecutable "$i/Info.plist")" )
            lib_dylibs+=( "$(basename "$i")/$(ExtractPlistValue CFBundleExecutable "$i/Info.plist")" )
        fi
    done < <(find "$dir/$tweakid/Tweak" ! -type l -iname '*.framework' ! -path '*PreferenceBundles/*' ! -path '*.bundle/*' ! -path '*.framework/*')

    # MOVING BUNDLES
    while read -r i; do
        rsync -a "$i" "Payload/$appname/"
        Verbose "Copied $(basename "$i") to app directory" "$(basename "$i") couldn't be copied to app directory" 16
    done < <(find "$dir/$tweakid/Tweak" ! -type l -iname '*.bundle' ! -path '*PreferenceBundles/*' ! -path '*.bundle/*' ! -path '*.framework/*')

    # FIXING LINKS
    for i in "${inject[@]}"; do
        ldid -r -M "$rpath/$i" &>/dev/null
        Verbose "Codesign stripped from $i" "Couldn't strip codesign from $i" 19 -v

        for l in $(otool -L "$rpath/$i" | cut -d ' ' -f1 | sort -u); do
            for x in "${inject[@]}"; do
                if [[ "$l" =~ $x ]]; then
                    if [[ "$l" =~ $i ]]; then
                        install_name_tool -id @rpath/"$i" "$rpath/$i" &>/dev/null
                        tid=$(( tid + $? ))
                        break
                    else
                        install_name_tool -change "$l" @rpath/"$x" "$rpath/$i" &>/dev/null
                        if ! [[ "${linked[*]}" =~ $x ]]; then
                            linked+=( "$x" )
                        fi
                        tlnk=$(( tlnk + $? ))
                        break
                    fi
                fi
            done
        done
    done

    # VERBOSE
    status="$tid"
    if [ -n "$tid" ]; then
        Verbose "ID Successful" "$tid file(s) failed to ID" 20 -x
    fi

    status="$tlnk"
    if [ -n "$tlnk" ]; then
        Verbose "Re-Link Successful" "$tlnk Re-Links failed" 21 -x
    fi

    # INJECT HOOKING LIBRARY
    if [ -n "${inject[*]}" ]; then
        for hookinglibrary in "libsubstitute.dylib" "CydiaSubstrate.framework/CydiaSubstrate"; do
            for i in "${inject[@]}"; do
                for l in $(otool -L "$rpath/$i" | cut -d ' ' -f1 | sort -u); do
                    if [[ "$l" =~ $hookinglibrary ]]; then
                        if [ ! -e "$rpath/$hookinglibrary" ]; then
                            if [[ "$hookinglibrary" =~ .framework ]]; then
                                hl_file="$(dirname "$hookinglibrary")"
                            else
                                hl_file="$hookinglibrary"
                            fi

                            if [ "$os" == "iOS" ]; then
                                rsync -a "/var/mobile/Azule/lib/$hl_file" "$rpath"
                            elif ! rsync -a "$AZULE/lib/$hl_file" "$rpath" &>/dev/null; then
                                Announce "$hl_file not downloaded, please run setup-azule." 22
                            fi
                        fi
                        install_name_tool -change "$l" @rpath/"$hookinglibrary" "$rpath/$i" &>/dev/null
                        status=$(( status + $? ))
                        break
                    fi
                done
            done
        done
        if [ -n "$status" ]; then
            Verbose "Linked $hookinglibrary" "Failed injecting $hookinglibrary in $status file(s)" 23 -x
        fi
    fi
    
    # MAKING SURE DEPENDENCIES WILL NOT BE INJECTED
    for l in "${linked[@]}"; do
        if [[ "${lib_dylibs[*]}" =~ $l ]]; then
            for i in "${!inject[@]}"; do
                if [ "$l" == "${inject[i]}" ]; then
                    unset "inject[i]"
                fi
            done
        fi
    done

    # MAKING SURE NOTHING WILL BE INJECTED TWICE
    for i in "${!inject[@]}"; do
        for l in $(otool -L "$executable" | cut -d ' ' -f1); do
            if [[ "$l" =~ /"${inject[i]}" ]]; then
                unset "inject[i]"
                break
            fi
        done
    done

    # INJECTING LIBRARIES
    for i in $(printf "%s\n" "${inject[@]}" | sort -u); do
        insert_dylib --inplace --weak --no-strip-codesig @rpath/"$i" "$executable" &> /dev/null
        Verbose "Injected $i" "Couldn't inject $i" 24
    done
fi

# REMOVING UISUPPORTEDDEVICES
if [ -n "$remove_uisd" ]; then
    UISupportedDevices="$(ExtractPlistValue UISupportedDevices Payload/"$appname"/Info.plist)"
    if [ -n "$UISupportedDevices" ]; then
        RemovePlistKey UISupportedDevices Payload/"$appname"/Info.plist
        Verbose "Removed UISupportedDevices from app" "Couldn't remove UISupportedDevices from app"
    fi
fi

# CHANGING BUNDLEID
if [ -n "$bundle" ]; then
    orig_bundleid="$(ExtractPlistValue CFBundleIdentifier Payload/"$appname"/Info.plist)"
    Verbose "Obtained Original BundleID" "Couldn't Obtain Original BundleID"

    while read -r i; do
        CFBundleIdentifier="$(ExtractPlistValue CFBundleIdentifier "$i")"
        if [[ "$CFBundleIdentifier" =~ $orig_bundleid ]]; then
            CFBundleIdentifier="${CFBundleIdentifier//"$orig_bundleid"/"$bundle"}"
            ReplacePlistValue "$CFBundleIdentifier" CFBundleIdentifier "$i"
            status=$(( status + $? ))
        fi
    done < <(find Payload/"$appname" -name "Info.plist")
    Verbose "Changed App BundleID to $bundle" "Couldn't Change App BundleID" -x
fi

# CHANGING DISPLAY NAME
if [ -n "$displayname" ]; then
    ReplacePlistValue "$displayname" CFBundleDisplayName Payload/"$appname"/Info.plist
    Verbose "Changed App Display Name to $displayname" "Couldn't Change App Display Name"
fi

# CHANGING VERSION
if [ -n "$custom_version" ]; then
    ReplacePlistValue "$custom_version" CFBundleVersion Payload/"$appname"/Info.plist
    ReplacePlistValue "$custom_version" CFBundleShortVersionString Payload/"$appname"/Info.plist
    Verbose "Changed App Version to $custom_version" "Couldn't Change App Version"
fi

# FAKESIGNING
if [ -n "$fakesign" ]; then
    Announce "Fakesigning iPA..."
        while read -r i; do
            ldid -s "$i" &>/dev/null
            Verbose "Fakesigned $(basename "$i")" "Couldn't Fakesign $(basename "$i")" -v 
        done < <(find Payload -type f ! -name "*.*" ! -name "CodeResources" ! -name PkgInfo)
    Verbose "Finished Fakesigning" "Couldn't Fakesign App"
fi

# CLEANING UP OUTDIR
if [ -e "$output" ]; then
    rm -rf "$output"
fi

# GENERATING IPA
if [ -n "$run" ] || [ -n "$unzipped" ]; then
    Announce "Generating iPA..."
    zip -rq "$output" Payload
    status="$?"
else
    mv "$ipadir" "$output"
    status="$?"
fi
Verbose "Generated IPA at $output" "Couldn't generate IPA" 25 -x 
